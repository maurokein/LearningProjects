Una característica de la COLECCIÓN como estructura de datos es que no solo es definida como un objeto que en sí mismo es capaz de contener otros objetos, sino que además puede obtener atributos propios para trabajar con él mismo como un objeto particular. Por ejemplo un carrito puede tener un atributo propio además de un arreglo que contiene productos de la compra de un cliente. A las colecciones se las trata de igual manera que a un objeto. Para que el cliente pueda comprar hay que tener una interfaz que permita la consulta y la navegación entre productos. Tanto el click del mouse sobre una categoría o la búsqueda en una caja de búsqueda, va a disparar un mensaje que se responderá con un método del objeto. Ese aspecto es dependiente de la tecnología (web o mobile, por ejemplo). El carro persiste de sesión en sesión, en algún momento el usuario hace el CHECKOUT -> hay un mensaje que le envía el usuario a la aplicación: "quiero terminar la compra". Quién recibe el mensaje? Habíamos puesto a la empresa glovo como fachada de la aplicación, aunque esa decisión de tener un objeto que funcione de fachada con el tiempo implicará una gran cantidad de mensaje y hubiera que refactorizar esa clase. En esta fase temprano, el objeto Glovo recibe un mensaje con el formulario que llenó el usuario: se está queriendo hacer un checkout de un objeto cliente, con una dirección de envío y con un medio de pago, todos los cuales son objeto. Hay un proceso intermedio donde las cosas que salen con String desde la interfaz, en algún momento un objeto que está en el BORDE DE LA APLICACIÓN, se las arregla para que esos strings recibidos se conviertan en objetos y a su vez sean reenviados al punto de la aplicación que los necesite. En este punto hay que arrancar un pedido, que es lo que el acarreador va a llevar al cliente. Eso es un objeto PEDIDO, de la clase homónima, fundamental para la app porque permite tener un log de los pedidos que hizo el cliente, un log mucho más preciso respecto a las compras: interesa saber CÓMO ARMÓ LOS PEDIDOS: algo que en el comercio real es también fundamental: por qué si un cliente llevó X, también llegó Y, etc -> ideas fundamentales para la inteligencia del negocio. Una vez hecho esto, hay dos modelos: se asigna arbitrariamente un producto al acarreador desocupado más cercano a la dirección. El otro modelo es notificar a todos los acarreadores, y que cada uno se postule a voluntad -> se envía a la colección Glover un mensaje para notificarse del pedido... La expresión debería refinarse enviando el mensaje solo a los acarreadores cercanos al objeto dirección de envío (decisiones para cambiar el algoritmo hay un montón, la primer implementación seguramente sea distinta a la final, aunque una vez creado el mensaje, con una localización correcta, lo único que habrá que cambiar será la implementación, mientras el resto del código no se verá modificado). En la medida que se maximiza la modularización la molestia de cambiar estructura de código se reduce. Hay que buscar que siempre que aparece una nueva funcionalidad, esa funcionalidad se desarrolla con un nuevo método, y a lo sumo implica inicializar una variable o un objeto en una clase que la conoce. Que un Glover se deba notificar significa que el tipo que llevará el producto se notifique, lo cual implica que se notifica a alguien 'externo' a la aplicación, lo que implica que la notificación se envía a la colección completa de glovers -> a cada glover se envía un NotificarseDe()... que está tanto en la colección como en los objetos individuales(un tipo de polimorfismo). Notificar a un objeto Glover y que la persona Glover se entere, se hace un tipo de razonamiento como sigue: vía wa, por ejemplo. Estamos en la línea de que a todos se notifica y los interesados se notifican. Eso significa que en el método NotificarseDe podríamos tener un código escrito en Java que envíe un mensaje de Whatsapp: un primer diseño válido implica encontrar una api que permite el envío de ese mensaje, y lo que pasaría es que en la clase Glover tendríamos código específico para mandar wa, que en principio sería tan sofisticado como compleja sea la api correspondiente, y esto se delega entonces en un OBJETO que se encarga de hacer la comunicación: ConexionConWhatsapp, donde está todo el código de comunicación, y entonces el método de notificarse de un pedido crea un objeto de conexión y a ese objeto le pide el envío de un mensaje de wa con un objeto pedido determinado. Esto es una capa de abstracción donde el objeto conector se encargará de mandar el mensaje. La clase Glover no se mete en este tema, lo pide. De este modo, ahora resulta que el objeto Glover debe conocer el número telefónico, el cual se agrega como atributo de la clase. Aparece entonces otro problema, que es que el objeto Conexión, al recibir el objeto Pedido, le estoy enviando algo que parece ser un poco complejo, puesto que hay un montón de cosas. Lo que se lee, sin embargo, en el mensaje, no es un pedido, entonces el objeto Pedido se transforma en texto, con un método específico que sea TransformarEnTexto(p)... A su vez quien recibe el mensaje, se puede postular. El glover con su interfaz clickea en una opción y define que se quiere postular. Cada glover debería conocer a la empresa de pedido. El algoritmo asigna de una manera particular: a veces el ganador se lleva todo, a veces el reparto es más igualitario. Por último se avisa al cliente que X glover será quien lleve el pedido solicitado. 
